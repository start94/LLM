# -*- coding: utf-8 -*-
"""Assistente _AI_Raffaele_Diomaiuto.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18euU_8wfH8Lgm7Gi6nKCqsgCe6gRjngQ

Per lo sviluppo di questo progetto ho scelto di adottare un approccio di programmazione procedurale anzich√© orientata agli oggetti.
Questa scelta nasce dall‚Äôesigenza di mantenere il codice semplice, lineare e facilmente leggibile,
considerando la natura specifica e limitata del task, che non richiede la modellazione di oggetti complessi o la gestione di molteplici stati.

In particolare, il progetto si basa su una serie di operazioni sequenziali (upload di un file, elaborazione del testo,
generazione di un riassunto, estrazione di attivit√†, validazione dei risultati ), perfettamente gestibili tramite funzioni autonome e ben separate.
 A mio parere, questo approccio √® pi√π rapido da implementare e debug, oltre che pi√π adatto in termini
di efficienza per script mirati come questo, dove la chiarezza e la modularit√† delle funzioni sono fondamentali.

Il codice svolge le seguenti funzioni principali:

üîß 1. Importazione delle librerie
All‚Äôinizio, il codice importa tutte le librerie necessarie per:

Interagire con OpenAI (openai)

Caricare file da Google Colab (files)

Lavorare con testo e pattern (io, re)

Gestire tipi di dato (typing)

üîê 2. Configurazione API OpenAI
Viene impostata una chiave API personale per accedere al modello GPT-4o-mini. Questo consente di inviare richieste al modello AI per generare riassunti e analizzare contenuti.

üì§ 3. Caricamento manuale del file
Il file meeting_transcription.txt viene caricato manualmente tramite interfaccia Colab. Dopo il caricamento, il contenuto del file viene letto e salvato come stringa.

üß† 4. Generazione del riassunto con AI
La funzione generate_summary invia la trascrizione al modello OpenAI con un prompt dettagliato. Il modello restituisce un riassunto strutturato del meeting, focalizzato su:
Temi discussi
Decisioni prese
Problemi riscontrati
Azioni da svolgere

Il riassunto √® pensato per essere professionale, sintetico e utile per la gestione aziendale.

‚úÖ 5. Estrazione delle attivit√†
La funzione extract_activities analizza la trascrizione per identificare tutte le attivit√† o compiti assegnati durante il meeting, anche quando non sono esplicitamente formulati. Se non √® presente un nome, viene assegnato a ‚ÄúTeam‚Äù o ‚ÄúDa assegnare‚Äù.

üîé 6. Validazione e controllo qualit√†
Il sistema esegue una serie di test automatici:
Riconosce i nomi dei partecipanti dalla trascrizione
Verifica se le attivit√† sono state effettivamente estratte
Controlla se i concetti principali sono presenti nel riassunto
Infine, calcola un punteggio di accuratezza da 0 a 100 che valuta:
Copertura dei partecipanti
Copertura dei concetti chiave
Numero di attivit√† rilevate
In base al punteggio, il sistema fornisce una valutazione qualitativa: Eccellente, Buono o Da migliorare.

üìã 7. Output finale
Alla fine, lo script stampa:

Il riassunto del meeting
L‚Äôelenco delle attivit√† identificate
Le metriche di validazione
Il tutto viene salvato anche in un file .txt scaricabile per l‚Äôarchiviazione o la condivisione.
"""



import openai
from google.colab import files
import io
import re
from typing import Dict, Set

print("‚úì Librerie importate con successo")
API_KEY = "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"
client = openai.OpenAI(api_key=API_KEY)

print(" Client OpenAI configurato") # per assicurami che tutto sia andato a buon fine

print("Carica il file meeting_transcription.txt:") # preferisco caricare il file manualmente in quanto mi d√† una maggiore sicurezza
uploaded = files.upload()

# Carica il contenuto del file
file_name = list(uploaded.keys())[0]
transcription = uploaded[file_name].decode('utf-8')

print(f" File caricato: {file_name}")
print(f" Lunghezza trascrizione: {len(transcription)} caratteri")


# funzione principale per generare il riassunto
def generate_summary(client, transcription):

    prompt = f"""
 Agisci come un esperto di riassunti di meeting aziendali ti verr√† fornito un file in txt : Analizza con attenzione la seguente trascrizione di un meeting aziendale e genera un riassunto professionale e conciso.

‚úÖ Il riassunto deve evidenziare:
- I temi principali discussi durante il meeting
- Le decisioni prese dal team
- Le problematiche evidenziate
- Le azioni da intraprendere

üìå Struttura l‚Äôoutput nel seguente formato:
- Tema/Decisione/Problema 1: descrizione breve
- Tema/Decisione/Problema 2: descrizione breve
- (e cos√¨ via‚Ä¶)
 Evita dettagli superflui, ripetizioni o trascrizioni letterali. Concentrati sui concetti strategici e organizzativi rilevanti.

Trascrizione del meeting:
\"\"\"
{transcription}
\"\"\"

Riassunto:
"""


    response = client.chat.completions.create(
        model="gpt-3.5-turbo",
        messages=[
            {"role": "system", "content": "Sei un assistente AI esperto nell'analisi di meeting aziendali. Genera riassunti chiari e concisi."},
            {"role": "user", "content": prompt}
        ],
        max_tokens=1400,
        temperature=0.3
    )

    return response.choices[0].message.content.strip()



def extract_activities(client, transcription):
    prompt = f"""
    Analizza la seguente trascrizione di un meeting e identifica tutte le attivit√†, compiti o azioni assegnate ai partecipanti.

    Struttura l'output in questo formato:
    - Nome Cognome: Descrizione dell'attivit√† assegnata
    - Nome Cognome: Descrizione dell'attivit√† assegnata

    Cerca frasi che indicano:
    - Compiti assegnati ("Mario, puoi fare...", "Andrea si occuper√† di...")
    - Azioni future ("Dovremmo fare...", "Bisogna implementare...")
    - Responsabilit√† ("Sar√† compito di...", "Chi pu√≤ occuparsene...")

    Se non ci sono nomi specifici, usa "Team" o "Da assegnare" come responsabile.

    Trascrizione:
    {transcription}

    Attivit√† Identificate:
    """

    response = client.chat.completions.create(
        model="gpt-3.5-turbo",
        messages=[
            {"role": "system", "content": "Sei un assistente esperto  AI nell'identificazione di attivit√† e compiti da trascrizioni di meeting."},
            {"role": "user", "content": prompt}
        ],
        max_tokens=1400,
        temperature=0.3
    )

    return response.choices[0].message.content.strip()



# funzioni di testing e validazione

def validate_participants(transcription):
    participants_pattern = r'([A-Z][a-z]+ [A-Z][a-z]+):'
    matches = re.findall(participants_pattern, transcription)
    participants = set(matches)
    print(f"‚úì Partecipanti identificati: {participants}")
    return participants

def validate_analysis(transcription, summary, activities):
    """Esegue la validazione completa dell'analisi"""
    print("\n" + "="*1)
    print("TESTING E VALIDAZIONE")
    print("="*1)

    # Test partecipanti
    participants = validate_participants(transcription)

    # Test attivit√†
    task_patterns = [
        r'([A-Z][a-z]+ [A-Z][a-z]+),?\s+(ti occupi|puoi|devi)',
        r'(ti occupi di|puoi prendere nota)',
        r'(avremo bisogno|dovremo|bisogna)'
    ]

    original_tasks = 0
    for pattern in task_patterns:
        matches = re.findall(pattern, transcription, re.IGNORECASE)
        original_tasks += len(matches)

    extracted_lines = [line.strip() for line in activities.split('\n')
                      if line.strip() and line.strip().startswith('-')]

    # Test concetti riassunto
    key_concepts = ['sistema contabile', 'interfaccia', 'reportistica',
                   'notifiche', 'email', 'archiviazione', 'documenti']

    concepts_in_summary = sum(1 for concept in key_concepts
                             if concept.lower() in summary.lower())

    # Calcolo metriche
    participant_coverage = len([p for p in participants if p in activities]) / len(participants) * 100
    concept_coverage = concepts_in_summary / len(key_concepts) * 100

    overall_score = (participant_coverage * 0.4 + concept_coverage * 0.4 +
                    min(100, len(extracted_lines)/max(1, original_tasks)*100) * 0.2)

    print(f"üìä METRICHE DI VALIDAZIONE:")
    print(f"   ‚Ä¢ Partecipanti: {len(participants)}")
    print(f"   ‚Ä¢ Copertura partecipanti: {participant_coverage:.1f}%")
    print(f"   ‚Ä¢ Copertura concetti: {concept_coverage:.1f}%")
    print(f"   ‚Ä¢ Attivit√† estratte: {len(extracted_lines)}")
    print(f"   ‚Ä¢ PUNTEGGIO FINALE: {overall_score:.1f}/100")

    if overall_score >= 80:
        print("   ‚Ä¢ VALUTAZIONE: ECCELLENTE ‚úÖ")
    elif overall_score >= 65:
        print("   ‚Ä¢ VALUTAZIONE: BUONO ‚úÖ")
    else:
        print("   ‚Ä¢ VALUTAZIONE: DA MIGLIORARE ‚ö†Ô∏è")

    return overall_score

print("‚úì Funzioni di validazione definite")

# da qui inizia l'analisi del meeting

print("üîÑ Inizio analisi del meeting...")

# Genera il riassunto
print("üìù Generazione riassunto...")
summary = generate_summary(client, transcription)

# Estrae le attivit√†
print("üìã Estrazione attivit√†...")
activities = extract_activities(client, transcription)

print("‚úÖ Analisi completata!")


# Formatta e mostra i risultati
output = f"""

 ANALISI MEETING - RISULTATI


 RIASSUNTO DEL MEETING:
{summary}



 ATTIVIT√Ä IDENTIFICATE:
{activities}


"""

print(output)

# Esegue la validazione
accuracy_score = validate_analysis(transcription, summary, activities)

# Salvataggio dei risultati con metriche
# Salva i risultati con metriche di validazione
enhanced_output = output + f"""

METRICHE DI VALIDAZIONE

PUNTEGGIO ACCURATEZZA: {accuracy_score:.1f}/100
by Raffaele Diomaiuto
"""

# salvo il risultato in un file .txt
filename_to_save = 'meeting_analisi_finale.txt'
with open(filename_to_save, 'w', encoding='utf-8') as f:
    f.write(enhanced_output)

# Stampa il nome del file salvato per conferma
print(f"üíæ Risultati salvati in '{filename_to_save}'")
files.download(filename_to_save)

print("‚úÖ Processo completato! File scaricato automaticamente.")